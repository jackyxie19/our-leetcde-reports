# MySQl

MySQL被设计成一个单进程多线程架构数据库，每个MySQL数据库实例在系统上的表现就是一个进程。

数据库与传统数据库最大的区别是数据库支持事务。

## 体系结构

### MyISAM与InnoDB对比：

|         特征          | MyISAM | InnoDB |
| :-------------------: | :----: | :----: |
|         事务          |   ×    |   √    |
|        锁粒度         |  表锁  |  行锁  |
| 多版本并发控制/快照读 |   ×    |   √    |
|       哈希索引        |   ×    |   √    |
|       全文索引        |   √    |   ×    |
|       聚簇索引        |   ×    |   √    |
|       外键索引        |   ×    |   √    |
|       数据缓存        |   ×    |   √    |
|     存储空间花费      |   低   |   高   |
|       内存花费        |   低   |   高   |
|     大量插入速度      |   高   |   低   |
|       压缩数据        |   √    |   ×    |

MyISAM和InnoDB均支持B+树索引、索引缓存、加密数据、复制、备份与时间点恢复、查询缓存；

MyISAM支持全文索引、表级锁、大量插入速度快、内存与存储空间花费低、压缩数据；

InnoDB支持事务、行级锁、MVCC、哈希索引、聚簇索引、外键索引、数据缓存、内存与存储空间花费高、大量插入速度慢。

存储引擎基于表，而不是数据库。

## InnoDB

特点：**行锁**、支持**外键**、提供**一致性非锁定读**、支持用裸设备建立表。通过**MVCC**提高并发性、实现四种SQL隔离级别、next-locking的策略来避免幻读。提供插入缓冲、二次写、自适应哈希索引、预读等。InnoDB采用聚簇方式按主键进行存放。

缓冲池设计的目的是为了协调CPU速度与磁盘速度的鸿沟。

为了避免数据丢失，当前事务数据库系统普遍采用 write ahead log策略，即当事务提交时，先写redo log 再修改页。

### 脏页/page cleaner

FLUSH_LRU_LIST Checkpoint是为了保证LRU列表中需要有大约100个空闲页可使用。1.2.x后放置于Page cleaner中。

Async/Sync Checkpoint是在重做日志不可用时，将一些脏页刷新回磁盘。为了保障redo日志的循环使用可用性。

1. checkpoint_age = redo_lsn - checkpoint;当checkpoint_age<async_water_mark时不做任何操作。
2. async_water_mark<checkpoint_age<sync_water_mark时触发async flush。
3. checkpoint_age>sync_water_mark时触发sync flush。

dirty page too much checkpoint：innodb_max_dirty_page_pct（最大允许脏页百分比）。

### Insert buffer

内存中有Insert buffer信息，但是insert buffer 与数据页一样，也在物理页中存储（共享表空间中的insert buffer，1.0后为change buffer）。

对于非聚集索引的插入或者更新操作，不是每一次直接插入到索引页中。而是先判断插入的非聚集索引页是否在缓冲池中，若在则直接插入；若不在则先放入insert buffer对象中。然后以一定的频率和情况进行Insert buffer和辅助索引叶子结点的merge操作。

使用Insert buffer 条件：索引为辅助索引（非聚集索引），索引不唯一。

Insert Buffer 用于非唯一索引的插入操作。

Insert Buffer数据结构为B+树，全局只有一棵B+树，负责对所有表的辅助索引进行Insert Buffer。这棵树存于共享表空间中，默认ibdata1。

### Change Buffer

InnoDB从1.0.x版本开始引入Change Buffer，可视为Insert Buffer 的升级。此时InnoDB开始对INSERT, DELETE, UPDATE进行缓冲，分别对应Insert Buffer, Delete Buffer, Purge Buffer。

对一条记录的update操作分为两个阶段：将记录标记为已删除，真正将记录删除。

系统表空间中的change buffer是数据库关闭时未合并change缓冲存放地。

引入change buffer 可以避免一有改变就进行昂贵的随机磁盘IO操作，而以批量的方式滞后更新。

Change buffer仅作用于辅助索引，聚集索引、全文索引等无效。

#### Merge insert buffer时机：

1. 辅助索引页被读取到缓冲池（在可被查询读取前合并）。Insert buffer bitmap 用于确认辅助索引页是否有存于Insert buffer 中的记录。
2. Insert buffer bitmap页追踪到该辅助索引页已无空间可用（内存中辅助索引页不足，强制进行磁盘操作）。
3. Master thread。

### Double write

Insert buffer 带来性能上的提升，Double write带来数据页可靠性（Consistency）。

在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会先将脏页复制到内存中的doublewrite buffer中，之后通过doublewrite buffer分两次写入共享表空间的物理磁盘上（此时写入顺序的）。在完成doublewrite页的写入后再写入各个表空间，此时写入是离散的。

默认情况下所有的页的刷新都先放入doublewrite中。

### 自适应哈希索引

InnoDB会监控表各项索引页的查询，会自动的建立自适应性哈希索引。AHI是通过缓冲池的B+树页构造而来，因此建立速度快，且不需对整张表构建哈希索引。

AHI要求对页访问模式必须一致，如a=xxx与a=xxx and b = xxx交替查询不会构建AHI。启动AHI后，读取和写入速度可提高2倍，辅助索引的连接操作可提高5倍。

AHI只能用于等值查询，如where a = xxx，不支持范围查询如where a < 1。

### 异步IO

用户可在发出一个IO请求后再立即发出下一个IO请求，当全部IO请求发送完毕后，等待所有IO操作的完成，这就是AIO。

AIO的另一个优势是可以进行IO Merge操作。

InnoDB 1.1.先开始提供内核级别AIO支持，称为Native AIO。Native AIO需要操作系统支持。

InnoDB中 read ahead方式的读取是通过AIO完成，脏页的刷新即磁盘的写入操作全部由AIO完成。

### 刷新邻接页

当刷新一个脏页时，InnoDB存储引擎会检测该页所在区(extent)的所有页，如果是脏页，那么一起刷新。



### 二进制日志

二进制日志记录了对MySQL数据库执行更改的所有操作，但不包括SELECT和SHOW这类操作。

二进制日志文件作用：

- 恢复：
- 复制：
- 审计：用户可以通过二进制日志文件判断是否有对数据库进行注入的攻击。

二进制日志文件在默认情况下并没有启动。

二进制日志是mysql数据库级别的日志，记录相关的更改操作。Redo日志是InnoDB表级别的日志。

### Redo日志

- 二进制日志文件会记录所有与MySQL数据库有关的日志记录，包括InnoDB、MyISAM、Heap等其他存储引擎的日志。而InnoDB存储引擎的redo日志只记录该引擎有关的事务日志。
- 记录的内容不同：无论用户将二进制日志文件设置为STATEMENT还是ROW，又或MIXED，其记录都是关于一个事务的具体操作内容，即该日志为逻辑日志。而InnoDB的Redo日志记录的是关于每个页更改的物理情况。
- 写入时间不同：二进制日志文件仅在事务提交前提交，只写盘一次，无论事务多大。而在事务进行的过程中，不断有重做日志条目（redo entry）被写入重做日志文件中。

## 表

索引组织表：根据逐渐顺序组织存放的表称为索引组织表。与索引组织表相对的是堆表，堆表按数据插入的顺序存放。堆表的特性决定了堆表上的索引均为非聚集索引。对于非聚集索引的离散读，堆表会比索引组织表快。

表空间有共享表空间和私有表空间。私有表空间只存放数据、索引、以及插入缓冲的Bitmap页（记录内存中插入缓冲有哪些页更新的副本）；回滚（undo）信息、插入缓冲索引页、系统事务信息、二次写缓冲等放在共享表空间中。

InnoDB逻辑存储结构为：

- 表空间：
- 段：段的管理由引擎自身完成。
- 区extent：区由连续的页组成，每个区大小为1MB，每个区有64个页。
- 页：一个页大小16KB。
- 行：InnoDB按行存储。

B+树索引本身并不能找到具体的记录，能找到知识该记录所在的页，数据库把页载到内存，然后通过Page Directory在进行二叉查找。

约束是一个逻辑的概念，用来保证数据的完整性，而索引是一个数据结构，既有逻辑上的概念，在数据库中还代表着物理存储的方式。

### 分区表partition table

分区的过程是将一个表或者索引分解为多个更小、更可管理的部分。从逻辑上讲，只有一个表或一个索引，但是在物理上这个表或索引可能由数十个物理分区组成。每个分区都是独立的对象，可以独自处理也可以作为一个更大对象的一部分进行处理。

MySQL数据库支持水平分区，不支持垂直分区。MySQL数据库分区是局部分区索引，一个分区中既存放了数据又存放了索引。而全局分区指，数据存放在各个分区中，但是所有数据的索引放在一个对象中。

MySQL支持的分区类型：

- RANGE分区：行数据基于属于一个给定连续区间的列值放入分区。5.5后开始支持RANGE COLUMNS分区。
- LIST分区：和RANGE分区类似，只是LIST分区面向的是离散值。
- HASH分区：用户自定义表达式。
- KEY分区：MySQL提供HASH函数。
- COLUMNS分区：COLUMNS分区可以直接使用非整型的数据（日期、字符串）分区，分区根据类型直接比较而得，不需要转化为整型。

## 索引

InnoDB存储引擎支持一下集中常见的索引：

- B+树索引：B+树索引不能找到一个给定键值的具体行，只能找到行所在的页。
- 全文索引：
- 哈希索引：InnoDB哈希索引是自适应的，不能人为干预是否在表中生成哈希索引。

平衡二叉树：任何节点的两个子树的高度差最大为1。平衡二叉树的查询速度很快，但是维护一颗平衡二叉树的代价非常大。

B+树是为磁盘或其他直接存取辅助设备设计的一种平衡查找树。

B+树主要用于磁盘结构，页的拆分（B+树页）意味着磁盘操作，应减少页拆分操作。B+树在Leaf页满而左右兄弟节点没满的情况下优先做旋转操作而非拆分叶子结点操作。

B+树通过填充因子来控制树的删除变化，50%是填充因子可设置的最小值。

B+树索引的本质就是B+树在数据库中的实现。B+树具有高扇出行，因此树高一般在2-4层。

数据库中的B+树可以分为聚集索引（clustered index）和辅助索引（secondary index），但两者内部都是B+树，即高度平衡，叶子结点存放所有数据。聚集索引与辅助索引不同在于叶子结点存放的是否是一整行数据。

### 聚集索引

InnoDB存储引擎是索引组织表，表中数据按照主键顺序存放。而聚集索引是按表主键构建一颗B+树，同时叶子结点存放整张表行记录，叶子结点也成为了数据页。聚集索引的特性决定了索引组织表中的数据也是索引的一部分（数据与索引一同存放）。数据页间通过双向链表连接。

多数情况下，查询优化器倾向于采用聚集索引。因为可直接在叶子结点找到整行数据。也因为数据顺序存放（逻辑上连续，物理上不一定连续），聚集索引排序查找及范围查找很快。如读取最新十条记录可通过双向链表从尾部直接读取10条记录。

数据页存放的是完整的行记录，而索引页仅存放键值及指向数据页的偏移量。



### 辅助索引

辅助索引叶子结点不包含全部行记录。叶子结点除包含键值外还含一个书签，指向索引对应的行数据。因InnoDB采用索引组织表，故书签指向相应行的聚集索引键。

对于聚集索引的修改，MySQL会新建一张表，再将数据拷贝进入，最后删除原表。辅助索引的创建不需要重建表，InnoDB会对索引表加一个S锁；辅助索引的删除只需更新内部视图，将辅助索引的空间标记被可用，并删除数据库内部视图对该索引的定义。

### Cardinality

Cardinality是预估的列选择性值。B+树索引应选择高选择性的列，即Cardinality/n_rows值接近于1的列。

InnoDB中Cardinality是抽样统计得到的值，其值更新策略为：表中1/16数据已发生改变，修改计数器值>$2\times 10^9$。

### 联合索引

联合索引是指对表上多个列进行索引。联合索引也采用B+树结构，只是索引列数大于等于2。

联合索引按创建时索引列顺序排序，查询时可左端部分列匹配，但不可跨中间列或从右侧列匹配。

当不考虑排序和分组时，将选择性最高的列放在前面通常是好的选择。

### 覆盖索引

个人认为覆盖索引是联合索引功能性的表达。InnoDB支持覆盖索引，即从辅助索引中可得查询记录，可避免对主键索引（聚集索引）的二次查询。

辅助索引较聚集索引小，若辅助索引可以涵盖查询的列，通过辅助索引查询可以减少IO操作（B+树索引页与数据页一起存放）。特别是计算统计信息时若联合索引可覆盖，可极大提高效率。如index(a,b,c)，执行select sum(c) from t where a=100 group by b.

### 全文检索

全文检索是将存于数据库中的单列的任意内容检索出来的技术。

#### 倒排索引

全文检索通常使用倒排索引实现。倒排索引同B+树一样是一个数据结构。它在辅助表中存放了单词与单词自身在一个或多个文档中所在位置的映射（word，documentId）。

全文索引表现形式为（word，（documentID，location））。

倒排索引将word存放到辅助表中。InnoDB为提高全文检索的并发性，设置了6张辅助表，每张表根据word的Latin编码分区。

![Search: The Inverted Index](servlet.ImageServer)

辅助表存于磁盘，InnoDB引入全文检索索引缓存FTS Index Cache来提高全文检索性能。FTS Index Cache是一颗**红黑树**，根据（word，list）进行排序。InnoDB总是在事务提交时将分词写入到FTS Index Cache中，再批量对辅助表更新。在全文检索查询时，会先将FTS Index Cache 中内容与辅助表合并再进行查询。数据库关闭时会将缓冲数据同步到磁盘辅助表中。

stopword列表表示其中的word不需要进行索引分词操作。

当前InnoDB全文检索存在限制：

- 每张表只能有一个全文检索索引。
- 多列组合而成的全文索引必须使用相同的字符集与排序规则。
- 不支持没有单词界定符的语言，如中文、日文、韩文等。



## 锁

数据库使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性保障。

### lock与latch

latch为轻量级锁，锁定时间短。InnoDB中分为mutex和rwlock，目的是保障并发线程操作临界资源的正确性，通常无死锁检测机制。

lock对象是事务，用来锁定数据库中对象，如表、页、行。一般lock仅在事务commit或rollback后释放。lock有死锁机制。

|          |             lock             |       mutex        |
| :------: | :--------------------------: | :----------------: |
| 上锁对象 |             事务             |        线程        |
| 保护内容 |          数据库内容          |    内存数据结构    |
| 持续时间 |         整个事务过程         |       临界区       |
|   模式   |      行锁、表锁、意向锁      |   读写锁、互斥量   |
| 死锁机制 | waits-for graph、time out 等 |     无死锁机制     |
|   位置   |     Lock Manager中哈希表     | 每个数据结构对象中 |

### 锁粒度

InnoDB实现了共享锁与排他锁两种行级锁。只S锁与S锁兼容，其他情况均不兼容。

意向锁将锁定的对象分为多个层次，意向锁标志事务希望在更细粒度上上锁。意向锁粒度有数据库、表、页。在对行上锁前需对响应库、表、页上意向锁。

- IS意向共享锁：事务想获得表中某几行记录的共享锁，如select ... for share。
- IX意向排它锁：事务想获得表中某几行记录的排它锁，如select ... for update。

| 锁兼容性 |  IS  |  IX  |  S   |  X   |
| :------: | :--: | :--: | :--: | :--: |
|  **IS**  |  √   |  √   |  √   |  ×   |
|  **IX**  |  √   |  √   |  ×   |  ×   |
|  **S**   |  √   |  ×   |  √   |  ×   |
|  **X**   |  ×   |  ×   |  ×   |  ×   |

事务在获取S锁之前，需先获得表级IS锁；获取X锁之前，需先获得IX锁。

### 一致性非锁定读

一致性非锁定读是指InnoDB通过MVCC方式来读取数据，若读取行被上X锁，则会读取最新的快照数据（undo）。快照数据通过undo段实现，undo用于事务回滚无额外开销。读取快照数据无需上锁，因不会有事务修改快照数据。

在提交读隔离级别下，非一致性数据总是读取最新的快照。在可重复读级别下，总是读取事务开始时的版本。

### 行锁的三种算法

- 单行记录锁：
- 间隙锁：锁定一个范围，不包含记录本身。
- next-key lock：间隙锁+行锁。

InnoDB对行的查询默认采用next-key lock算法。当查询索引有唯一属性时，InnoDB会优化将next-key lock降级为行锁。对于聚集索引，仅上行锁；而辅助索引需上next-key lock，还会对该辅助索引下一个键值上间隙锁。

间隙锁作用是防止多个失误将记录插入到同一个范围内导致的幻象问题。

### 三级锁协议

一级锁协议：事务修改数据前获取写锁（排它锁），事务结束后释放。读取数据无需加锁，可产生脏读现象。对应事务隔离级别中的未提交读（read uncommitted）。

二级锁协议：在一级锁协议基础上增加读锁（共享锁），读取操作前获取读锁，读后立即释放。可避免脏读现象，但在同一事务过程中多次读取可能出现不可重复读现象。

三级锁协议：在二级锁协议读锁基础上修改读锁持续区间，事务读取数据前获得写锁，事务结束后释放。可避免不可重复读现象，但可能出现幻读现象（区间查询，区间内被其他事务插入数据，可通过区间锁解决）。

### 锁问题

#### 脏读

脏数据是未提交的数据。读到脏数据是指一个事务读取到另一个事务未提交的数据，违反数据库的隔离性。

脏页是因为数据库实例内存和磁盘的异步造成的，并不影响数据一致性（两者最终会达到一致）。脏页的刷新是异步的，不影响数据库可用性，可提高性能。

#### 不可重复读

不可重复读指在一个书屋内多次读取同一数据集合。在事务结束前另一事务提交了对该集合的DML操作。脏读读到的是另一事务未提交的数据，而不可重复读是过程中先读取到事务提交前数据后读取到提交后数据。一般来说不可重复读问题可以接受，因为读取到的是已提交数据，本身不会带来很大问题。

#### 幻读

范围查询过程中其他事务插入了范围内的数据，导致事务内前后两次查询结果不一致。范围锁可以避免幻读，间隙锁、next-key locking。幻读属于不可重复读的特殊情况。

#### 丢失更新

丢失更新是指一个事务的更新被另一个事务更新覆盖。如r1(x=100),r2(x=100),w1(x=200),w2(x=300),c1,c2。事务2提交的更新会使事务1更新丢失。可通过select for update让读锁排他，也可将事务隔离级别设置为serializable。

### 死锁

若程序是串行的，那么不可能发生死锁。死锁只存于并发情况，而数据库本身就是一个并发运行程序。死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待现象。

死锁产生的条件：

1. 资源互斥
2. 请求保持
3. 不可剥夺
4. 循环等待

破坏死锁产生的四个条件预防死锁称为死锁预防。

防止系统进入不安全状态避免死锁称为死锁避免，死锁避免通常用银行家算法解决。

解决死锁最简单的方式是不要有等待，将任何的等待都化为回滚，并重新开始该事务。此种方案属于死锁预防中破坏循环等待条件，死锁进程主动放弃资源。对此的一个改进是引入超时时间，在达到超时时间后选择代价较小的事务进行回滚，将循环等待改为有限等待。可将改进理解为死锁预防，亦可将超时理解为一种死锁检测机制。

数据库还普遍采用wait-for graph等待图的方式来进行死锁检测。相对于超时触发死锁处理机制，等待图是一种更为主动的死锁检测方式。

wait-for graph要求数据库保存以下两种信息：锁的信息链表、事务等待链表。通过上述链表构造有向图，若图存在回路则有死锁。

InnoDB一般在检测到死锁后回滚undo量最小的日志。

## 事务

事务会把数据库从一种一致性状态转化为另一种一致性状态，事务要么全做要么全不做，也是数据库区别于文件系统给的重要特征之一。

### 分类

#### 扁平事务

最简单、使用最频繁的事务。所有的操作都处于同一层次，BEGIN开始，COMMIT WORK或ROLL BACK结束。扁平事务是应用程序称为原子操作的基本组成模块。 如果支持有计划的回滚操作，那么就不需要终止整个事务。就出现了带有保存点的扁平事务。

#### 带保存点的扁平事务

保存点用于通知系统记住事务当前状态，以便发生错误时能回到保存点状态。

#### 链事务

链事务可视为保存点事务的一个变种。因保存点易失，当系统崩溃时，所有的保存点都将消失。链事务在提交事务时释放不需要的数据对象，将必要的处理上下文隐式传给下一个事务。注意，提交事务操作和开始下一个事务操作将合并为一个原子操作。

带有保存点的事务可以回滚到任意正确的保存点，而链事务仅能回滚到最近一个保存点。

#### 嵌套事务

- 嵌套事务是由若干事务构成的一棵树，子树既可以是嵌套事务，又可以是扁平事务。
- 处在叶节点的事务是扁平事务。
- 位于根节点的称为顶层事务，其他事务称为子事务。
- 子事务既可以提交也可以回滚。子事务在顶层事务提交后才生效。
- 树中任意一个事务回滚会回滚所有子事务，故子事务仅保留ACI特性，不具D特性。

不同子事务在数据库对象上持有的锁是不同的。父事务可以不传递锁，也可以传递所有锁，也可以值传递一个排它锁。

#### 分布式事务

分布式事务通常是一个在分布式环境下运行的扁平事务。InnoDB支持扁平事务、带保存点的扁平事务、链事务、分布式事务，对于嵌套事务并不原生支持。

### 事务的实现

事务隔离性由锁实现，ACD由redo和undo日志实现。redo用于保障原子性与持久性，undo用于保障一致性。undo日志用于帮助事务回滚及MVCC功能。Redo 日志基本是顺序写，在数据库运行过程中不需要对redo日志文件进行读取操作；而undo日志是需要进行随机读写的。

undo并非redo的逆过程，两者都可视为一种恢复操作，redo用于恢复事务修改的也操作，而undo用于回滚行到某个特定的版本。两者记录的内容不同，redo通常是物理日志，记录的是页的物理修改操作；undo是逻辑日志，根据每行记录进行记录。redo日志要保障故障恢复的幂等性，故直接存放物理页操作。

#### redo

redo日志用来实现事务持久性，由两部分组成：一是内存中易失的重做日志缓冲；二是磁盘中持久的重做日志文件。

为保证每次日志都写入重做日志文件，每次将redo buffer写入重做日志文件后都需调用一次fsync操作。

MySQL中还有一种二进制文件binlog，用来进行POINT-IN-TIME（PIT）的恢复及主从复制环境的建立。两者的区别如下：

1. redo日志由InnoDB产生，而binlog由MySQL产生。MySQL任何引擎对数据库的更改都会产生binlog。
2. 记录内容形式不同：binlog是一种逻辑日志，记录的是对应SQL语句；而redo日志是物理日志，记录的是对每个页的修改。
3. 写入磁盘时间点不同：binlog只在事务提交完成后一次性写入。而redo日志在事务进行中不断写入，表现为日志并不是随事务提交的顺序进行写入的。

InnoDB中重做日志以512字节为代为存储。redo、undo日志都是以块（block）的方式进行保存的，每块大小512字节。由于redo日志块的大小和磁盘扇区大小一致，均为512字节，故重做日志的写入可以保证原子性，不需要doublewrite技术。

#### undo

redo存放于重做日志文件中，undo存放在数据库内部的一个特殊段中，称为undo段。undo段位于共享表空间。undo是逻辑日志，只能将数据库逻辑上恢复到原来样子。

除了回滚操作，undo的另一个作用是MVCC。undo日志也会产生redo日志，因为undo日志也需要持久性保护。

InnoDB1.2后支持将undo日志独立存放于undo表空间中。

事务在undo段分配页并写入undo日志的过程同样需要写入redo日志。在事务提交时，InnoDB先将undo日志放入列表供后续的purge操作；再判断undo日志是否可用，若可用则分配给下个事务使用。

事务提交后并不能马上删除undo日志及对应页，因为可能由其他事务通过undo日志获取之前版本记录。是否可删除undo日志及其页由purge线程判断。

InnoDB中undo分为：insert undo log 与 update undo log。

- insert操作只对事务本身可见，对其他事物不可见，故该undo页在事务提交后直接删除，无需purge操作。
- update undo log对应delete和update操作。该undo log可能需要提供MVCC机制，因此不能在事务提交时就删除。事务提交时将其加入undo log链表，由purge线程完成删除操作。delete操作仅标记该页为删除，由purge完成最后工作。

#### purge

因为InnoDB设计为支持MVCC，所以记录不嗯呢该在事务提交时立即处理。使用purge来清理之前的delete和update操作。

为保证数据库上层binlog与InnoDB事务提交顺序一致，MySQL内部使用了prepare_commit_mutex锁。